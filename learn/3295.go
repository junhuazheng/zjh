/*Go语言带缓冲的通道
在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道
带缓冲通道在发生时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞
同理，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞

无缓冲通道保证收发过程同步。
无缓冲收发过程类似于快递员给你打电话让你下楼去快递，这个递交快递的过程是同步发生的，你和快递员不见不散
但这样做快递员就必须等待所有人下楼完成操作后才能完成所有投递工作。
如果快递员将快递放入快递柜中，并通知用户来取，快递员和用户就完成了异步收发过程
效率可以有明显的提升，带缓冲的通道就是这样一个“快递柜“*/

/*创建带缓冲通道
  创建带缓冲的通道格式：*/

//通道实例 := make(chan 通道类型, 缓冲大小)

/*通道类型：和无缓冲通道用法一致，影响通道发送和接受的数据类型
缓冲大小：决定通道最多可以保存的元素数量
通道实例：被创建出的通道实例*/

package main

import "fmt"

func main() {

	ch := make(chan int, 3)

	/*查看当前通道的大小。
	带缓冲的通道在创建完成时，内部的元素是空的，因此使用len()获取到的返回值为0*/
	fmt.Println(len(ch))

	/*发送3个整型元素到通道
	因为使用了缓冲通道。即便没有goroutine接收，发送者也不会发生阻塞*/
	ch <- 1
	ch <- 2
	ch <- 3

	fmt.Println(len(ch))
}

/*阻塞条件
带缓冲通道在很多特性上和无缓冲通道是类似的。
无缓冲通道可以看作是长度永远为0的带缓冲通道。
因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞：
1）带缓冲通道被填满时，尝试再次发送数据时发生阻塞
2）带缓冲通道为空时，尝试接受数据时发生阻塞

为什么Go语言对通道要限制长度而不是无限长度的通道？
我们知道通道（channel）是在两个goroutine间通信的桥梁。
使用goroutine的代码必然有一方提供数据，一方消费数据。
当提供数据一方的数据提供给速度大于消费放的数据处理速度市，如果通道不限制长度，那么内存将不断膨胀知道应用崩溃
因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常处理数据