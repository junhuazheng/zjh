/*
defer调用会在当前函数执行结束前才被执行，这些调用被称为延迟调用。
defer中使用匿名函数依然是一个闭包
*/

package main

import "fmt"

func main() {
	x, y := 1, 2

	defer func(a int) {
		fmt.Printf("x: %d, y: %d\n", a, y) //y为闭包引用
	}(x) //在函数执行前复制x的值，此时x = 1， 所以赋值的x的值为1

	x += 100
	y += 100
	fmt.Println(x, y)

}

/*
输出结果为
101 102
x: 1, y: 102
*/

/*
从形式上看，匿名函数都是闭包。
闭包的使用非常灵活，不当的使用容易产生难以发现的bug
当出现意外情况时，首先检查函数的参数，声明可以接受参数的匿名函数，这些类型的闭包问题也就迎刃而解了。
*/
